<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>葡萄藤PPT</title>

    <link rel="stylesheet" href="./css/reveal/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="./css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="./lib/reveal/css/zenburn.css">

    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? './css/reveal/print/pdf.css' : './css/reveal/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
    <style type="text/css">
        h3 {
            font-family: 'Microsoft Yahei';
        }

        p {
            font-size: 30px !important;
            letter-spacing: 2px;
            line-height: 50px !important;
            text-align: left;
        }

        B {
            color: rgb(195, 255, 219);
            font-size: 40px !important;
            font-weight: 500 !important;
        }

        a {
            color: #fff !important;
        }
    </style>
</head>
<body>
<img src="./img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
<map name="pttmap">
    <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com" alt="" target="_blank"/>
</map>
<div class="reveal">
    <div class="slides">
        <section>
            <h2>【JS-task2】</h2>

            <h3>关于事件的点点滴滴</h3>

            <h3>小课堂</h3>

            分享人：黄诚翰
        </section>
        <section>
            <p style="text-align: center;">目录</p>
            <p style="text-align: center;">1.背景介绍</p>
            <p style="text-align: center;">2.知识剖析</p>
            <p style="text-align: center;">3.常见问题</p>
            <p style="text-align: center;">4.解决方案</p>
            <p style="text-align: center;">5.编码实战</p>
            <p style="text-align: center;">6.扩展思考</p>
            <p style="text-align: center;">7.参考文献</p>
            <p style="text-align: center;">8.更多讨论</p>
        </section>
        <!--1.背景介绍-->
        <section>
            <section>
                <h3>1.背景介绍</h3>
            </section>
            <section>
                <p>
                    讲到js的事件机制，我们就能来了解一下什么是事件，先举个例子：
                </p>
                <p>
                    比如说，人都会睡觉，但只有人感到困倦的时候才会去睡觉。让我们来用程序写一下
                </p>
                <pre>
                    <code>
                        function sleep() {
                            do sleep;
                        }
                        people.ontired = function(){
                            sleep();
                        }
                    </code>
                </pre>
            </section>
            <section>
                <p>
                    当然我们修真院的师兄弟们都是修仙之人，当然不与这等凡人苟同。
                </p>
                <pre>
                    <code>
                        function coding() {
                            coding;
                        }
                        people.ontried=function(){
                            coding();
                        }
                    </code>
                </pre>
            </section>
            <section>
                <p>所以事件这种东西是广泛存于我们周围的，也就是一个触发点，就像一个开关一样，按下灯开关灯就亮了，再按一下就关了，这就是一个事件</p>
                <p>把事件放在web中，准确的说是放到浏览器中，事件就会变为用户对浏览器所做的行为的响应。比如简单的点击、键盘、移动鼠标、关闭网页等等，只要浏览器能对用户行为做出响应的，都是web的事件，比如让德国boy怒砸电脑，抱歉浏览器真的无法监听这个“事件”所以算不上web事件</p>
                <p>所以，事件是浏览器对用户行为的一个响应。</p>
            </section>
        </section>
        <!--2.知识剖析-->
        <section>
            <h3>2.知识剖析</h3>
        </section>
        <!--2.1 JS有哪些数据类型？-->
        <section>
            <section><B>2.1 js的事件驱动</B></section>
            <section>

                    <p>
                        js是事件驱动，正是有这些事件的存在，前端才能和用户联系起来，我们一般不清楚用户对网页做了什么，但是外门知道用户做了那些行为后应该给与怎么样的处理。可以把自己想象成一个地雷兵，在页面中布满地雷了大大小小的“事件地雷”，只要用户不睬上去，我们的代码只能老老实实躺在js中不会触发，只要用户踩到了“地雷”，那么我们的地雷就可以瞬间boom</p>
                    <pre>
                        <code>
                            document.body.onclick=function(){
                                alert('boom');
                            }
                        </code>
                    </pre>
            </section>
            <section>
                <p>
                    如果用户只是打开了网页，没有进行点击，那么这个boom就永远不会弹出，因为js是事件驱动的。
                </p>
                <p>
                    讲了这么多事件驱动，那么总结一下什么是事件驱动好了，事件没有发生，那么我们写的js代码就不会执行，事件是触发代码执行的直接原因。
                </p>
                <p>
                    一般来讲，如果在一个点击事件里写上几个逻辑错误，页面加载的时候是不会给你报错的，浏览器只是看了一眼onclick里面的内容，但不会去执行，自然是不会看到里面的逻辑错误，除非你在里面谢了几个语法错误，加载的时候发现，卧槽，读不通啊，他才会提示错误。当你点击事件触发的时候，js执行了代码，发现里面的逻辑狗屁不通，就会自然而然的报错了
                </p>
                </section>
                <section>
                <p>
                    通常我们都会写个window.onload，页面加载完成触发的事件，把要执行的代码放在里面，这样资源加载好了js好操作。但是页面中还存在一个硬性的事件，就是read，js引擎阅读代码事件。如果读到了function 函数名(){...}活着var 函数名=function(){...}这样的结构，它会匆匆扫一眼，不执行里面的代码，然后继续读下去，其他的语句一旦遇到了，js就会去执行它。比如var 变量名或着函数名()这样。这个是read事件，其他事件也类似，只有当前浏览器对用户行为的响应时，js才会执行里面的代码。
                </p>
            </section>
            <section><B>2.2 js常见事件</B></section>
            <section>
                <p>
                    1、窗口事件,只在body和frameset元素中才有效
                </p>
                <p>
                    onload      页面或图片加载完成时<br>
                    onunload     用户离开页面时<br>
                </p>
            </section>
            <section>
                <p>
                    2、表单元素事件,在表单元素中才有效
                </p>
                <p>
                        onchange     框内容改变时<br>
                        onsubmit     点击提交按钮时<br>
                        onreset     重新点击鼠标按键时<br>
                        onselect     文本被选择时<br>
                        onblur      元素失去焦点时<br>
                        onfocus     当元素获取焦点时<br>
                </p>
            </section>
            <section>
                <p>3、键盘事件,在base,bdo,br,frame,frameset,head,html,iframe,meta,param,script,style,title元素里都无效</p>
                <p>
                        onkeydown    按下键盘按键时<br>
                        onkeypress    按下或按住键盘按键时<br>
                        onkeyup     放开键盘按键时<br>
                </p>
            </section>
            <section>
                <p>4、鼠标事件，在base,bdo,br,frame,frameset,head,html,iframe,meta,param,script,style,title元素里都无效</p>
                <p>onclick     鼠标点击一个对象时<br>
                   ondblclick    鼠标双击一个对象时<br>
                   onmousedown 鼠标被按下时<br>
                   onmousemove 鼠标被移动时<br>
                   onmouseout    鼠标离开元素时<br>
                   onmouseover 鼠标经过元素时<br>
                   onmouseup    释放鼠标按键时</p>
            </section>
            <section>
            <p>5、其他
                    </p>
            <p>onresize     当窗口或框架被重新定义尺寸时<br>
                    onabort     图片下载被打断时<br>
                    onerror     当加载文档或图片时发生错误时</p>
        </section>
            <section>
                <p>2.3 js中事件处理程序的几种方式</p>
            </section>
            <section>  
                <p>产生了事件，我们就要去处理它,js中事件处理程序主要有3种方式：</p>
                <p>1、HTML事件处理程序</p>
                <p>即我们直接在HTML代码中添加事件处理程序，如下面这段代码：</p>
                <pre>
                    <code>
                            <input id="btn" value="按钮" type="button" onclick="showmsg();">
                            　　<script>
                            　　 function showmsg(){
                            　　 alert("HTML添加事件处理");
                            　　 }
                            　　</script>
                    </code>
                </pre>
            </section>
            <section>
                <p>2、DOM0级事件处理程序</p>
                <p>
                    即为指定对象添加事件处理，看下面的一段代码：
                </p>
                <pre>
                    <code>
                            <input id="btn" value="按钮" type="button">
                            　　<script>
                            　　　　var btn= document.getElementById("btn");
                            　　 btn.onclick=function(){
                            　　　　　　alert("DOM级添加事件处理");
                            　　　　} 
                            　　　　btn.onclick=null;//如果想要删除btn的点击事件，将其置为null即可
                            　　</script>
                    </code>
                </pre>
            </section>
            <section>
                <p>3、DOM2级事件处理程序</p>
                <p>
                        DOM2也是对特定的对象添加事件处理程序，但是主要涉及到两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()和 removeEventListener()。它们都接收三个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值（是否在捕获阶段处理事件）如果为true，表示在捕获阶段调用事件处理程序，如果是false，表示在冒泡阶段调用事件处理程序，看下面的一段代码：
                </p>
                <pre>
                    <code>
                            <input id="btn" value="按钮" type="button">
                            　　<script>
                            　　 var btn=document.getElementById("btn");
                            　　 btn.addEventListener("click",showmsg,false);//这里我们把最后一个值置为false，即不在捕获阶段处理，一般来说冒泡处
                            理在各浏览器中兼容性较好
                            　　 function showmsg(){
                            　　 alert("DOM级添加事件处理程序");
                            　　 }
                            　　 btn.removeEventListener("click",showmsg,false);//如果想要把这个事件删除，只需要传入同样的参数即可
                            　　</script>
                    </code>
                </pre>
            </section>
            <section>
                2.4 事件的三个阶段
            </section>
            <section>
                <p>
                        ①捕获阶段：<br>
                        事件从根节点流向目标节点，途中流经各个DOM节点，在各个节点上触发捕获事件，直到达到目标节点。<br>
                        
                        捕获阶段的主要任务是建立传播路经，在冒泡阶段根据这个路经回溯到文档根节点<br>
                        
                        ②目标阶段 <br>
                        
                        事件到达目标节点时，就到了目标阶段，事件在目标节点上被触发<br>
                        
                        ③冒泡阶段 <br>
                        
                        事件在目标节点上触发后，不会终止，一层层向上冒，回溯到根节点。
                </p>
                <p>
                        DOM2级包含3个事件：事件捕获阶段、处于目标阶段和事件冒泡阶段
                </p>
            </section>
            <section>
                <p>
                        1.事件冒泡（常用）
                </p>
                <img src="http://jns.img.bucket.ks3-cn-beijing.ksyun.com/skill/daily/5d334ebb-16ce-4a90-8942-ceea7de44c38.png">
                <p>
                        IE中采用的事件流是事件冒泡，先从具体的接收元素，然后逐步向上传播到不具体的元素。
                </p>
            </section>
            <section>
                <pre>
                    <code>

                                    <div id="all">
                                    
                                        <div>div1</div>
                                    
                                        <div>div2</div>
                                    
                                    </div>
                                    
                                    <script>
                                    
                                       
                                    
                                        document.getElementsByTagName('body')[0].addEventListener('click', function(e) {
                                    
                                            alert(1);
                                    
                                        }, false);
                                    
                                         document.getElementById('all').addEventListener('click', function(e) {
                                    
                                            alert(2);
                                    
                                        }, false);
                                    
                                    </script>
                    </code>
                </pre>
            </section>
            <section>
                <p>2.事件捕获（少用）</p>
                <img src="http://jns.img.bucket.ks3-cn-beijing.ksyun.com/skill/daily/b0c8e427-7098-4459-853e-0e9cfeb17b7d.png">
                <p>Netscapte采用事件捕获，先由不具体的元素接收事件，最具体的节点最后才接收到事件。</p>
            </section>
            <section>
                <pre>
                    <code>
                            <div id="all">

                                    <div>div1</div>
                                
                                    <div>div2</div>
                                
                                </div>
                                
                                <script>
                                
                                    //将这里的false，改成true.表明body的绑定事件发生在捕获阶段
                                
                                    document.getElementsByTagName('body')[0].addEventListener('click', function(e) {
                                
                                        alert(1);
                                
                                    }, true);
                                
                                     document.getElementById('all').addEventListener('click', function(e) {
                                
                                        alert(2);
                                
                                    }, false);
                                
                                </script>
                                
                                点击body区域:alert(1)
                                
                                点击all区域:alert(1) alert(2)
                    </code>
                </pre>
            </section>
            <section>
                <p>3.DOM事件流</p>
                <img src="http://jns.img.bucket.ks3-cn-beijing.ksyun.com/skill/daily/25c1e653-5fde-4ee3-801f-bf8af5b5907f.png">
                <p>dom2级事件比起dom0级事件的好处就是，addEventListener() 增加多个dom事件，触发时都会依次发生，而DOM0级只能覆盖，不会连续触发。</p>
            </section>
        </section>
        <!--3.常见问题-->
        <section>
            <h3>3.常见问题</h3>
        </section>
        <!--5.编码实战-->
        <section>
            <h3>5.编码实战</h3>
        </section>
        <!--6.拓展思考-->
        <section>
            <h3>6.拓展思考</h3>
        </section>
        <section>
            <p>关于阻止冒泡事件和默认事件</p>
            <p>1、阻止冒泡事件

                    其实在非IE浏览器中提供了一个事件对象 stopPropagation，那么在IE浏览器中有通过cancelBubble事件对象可以阻止。
                    
                    语法部分：
                    
                    stopPropagation() 方法
                    
                    定义和用法
                    
                    不再派发事件。
                    
                    终止事件在传播过程的捕获、目标处理或起泡阶段进一步传播。调用该方法后，该节点上处理该事件的处理程序将被调用，事件不再被分派到其他节点。
                    
                    语法
                    
                    event.stopPropagation()
                    
                    说明
                    
                    该方法将停止事件的传播，阻止它被分派到其他 Document 节点。在事件传播的任何阶段都可以调用它。注意，虽然该方法不能阻止同一个 Document 节点上的其他事件句柄被调用，但是它可以阻止把事件分派到其他节点。
                    
                    
                    
                    代码部分：</p>
                    <img src="http://jns.img.bucket.ks3-cn-beijing.ksyun.com/skill/daily/2dbb8432-f3a0-4cac-92d0-2d043685d167.png">

        </section>
        <section>
            <p>
                
            </p>
        </section>
        <section>
            <h3>7.参考文献</h3>
        </section>
        <section>
            <h3>8.更多讨论</h3>
        </section>
        <section>
            <p style="text-align: center">感谢大家观看
            <p style="text-align: center">
                <small>BY : 黄诚翰</small>
        </section>
        <script src="./lib/reveal/js/head.min.js"></script>
        <script src="./lib/reveal/reveal.js"></script>
    </div>
</div>
<script>
    // 以下为常见配置属性的默认值
    // {
    // 	controls: true, // 是否在右下角展示控制条
    // 	progress: true, // 是否显示演示的进度条
    // 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
    // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
    // 	keyboard: true, // 是否启用键盘快捷键来导航
    // 	overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
    // 	center: true, // 是否将幻灯片垂直居中
    // 	touch: true, // 是否在触屏设备上启用触摸滑动切换
    // 	loop: false, // 是否循环演示
    // 	rtl: false, // 是否将演示的方向变成RTL，即从右往左
    // 	fragments: true, // 全局开启和关闭碎片。
    // 	autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
    // 	transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
    // 	transitionSpeed: 'default', // 过渡速度，default/fast/slow
    // 	mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
    // }
    // 初始化幻灯片
    Reveal.initialize({
        history: true,
        dependencies: [
            {src: './plugin/markdown/marked.js'},
            {src: './plugin/markdown/markdown.js'},
            {src: './plugin/notes/notes.js', async: true},
            {src: './plugin/highlight/highlight.js', async: true, callback: function () {
                    hljs.initHighlightingOnLoad();
                }
            }
        ]
    });
</script>
</body>
</html>
